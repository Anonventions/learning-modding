# 9. Registry Systems

> **Wiki home:** [Home](Home) | **Previous:** [Example Mod Setup](8.-Example-Mod-Setup) | **Next:** [Events & Networking](10.-Events-Networking)

This page covers how to safely register custom game objects (blocks, items, entities, dimensions, sounds, etc.) using NeoForge's **DeferredRegister** system, and how to organize registries for maintainability and safety.

---

## üéØ What is a Registry?

A **registry** is a global, immutable map that Minecraft maintains for every type of game object. When you create a custom block, item, or entity, you must register it so the engine can find and manage it.

### Built-in Registries

| Registry | Purpose | Examples |
|---|---|---|
| **BLOCK** | All placeable blocks | Stone, Dirt, Custom Ruby Ore |
| **ITEM** | All items (including block items) | Swords, Books, Custom Ingot |
| **ENTITY_TYPE** | All living and non-living entities | Zombies, Arrows, Custom Golem |
| **SOUND_EVENT** | All sound effects | Step sounds, attack sounds, custom "ruby_break" |
| **PARTICLE_TYPE** | Visual particle effects | Flame, smoke, custom "ruby_sparkle" |
| **POTION** | Potion effects | Speed, Strength, custom "ruby_power" |
| **MOB_EFFECT** | Status effects applied to entities | Poison, Haste, custom effects |
| **BLOCK_ENTITY_TYPE** | Complex blocks with storage | Chests, Furnaces, custom machines |
| **FEATURE** | World generation structures | Trees, Ores, custom dungeon |
| **STRUCTURE_TYPE** | Named structures for world gen | Stronghold, Village, custom temple |
| **LOOT_CONDITION_TYPE** | Conditions for loot tables | "random_chance", "has_tool" |
| **PAINTING_VARIANT** | Paintings and decorations | Paintings with custom textures |

---

## üõ°Ô∏è Why DeferredRegister?

Before DeferredRegister existed, developers had to manually instantiate objects during specific loading phases. This caused **initialization order bugs** where a registering block would try to reference an item that hadn't been registered yet.

**DeferredRegister** solves this by deferring all registrations until the game explicitly asks for them. Your code simply **declares what should be registered**, and the loader handles the actual registration timing automatically.

### Bad approach (pre-1.21 pattern):

```java
// ‚ùå Fragile; depends on order of instantiation
public static final Block RUBY_ORE = new Block(...);
public static final Item RUBY_ORE_ITEM = new BlockItem(RUBY_ORE, ...);
```

Problems:
- If `RUBY_ORE` hasn't finished initialization when `RUBY_ORE_ITEM` tries to reference it, it crashes
- Impossible to detect static initialization order issues until runtime

### Good approach (modern DeferredRegister):

```java
// ‚úÖ Safe; registration happens in the correct phase
public static final RegistryObject<Block> RUBY_ORE = BLOCKS.register("ruby_ore", () ->
    new Block(...)
);

public static final RegistryObject<Item> RUBY_ORE_ITEM = ITEMS.register("ruby_ore", () ->
    new BlockItem(RUBY_ORE.get(), ...)  // Safe to call .get() here
);
```

Benefits:
- Registry initialization order is guaranteed by the loader
- Easy to see what's being registered just by reading the code
- Lazy initialization (objects are created only when needed)

---

## üìù Setting Up Registries in Your Mod

### Step 1: Create Registration Classes

In your mod's main package, create separate classes for each registry type:

```java
// com.example.mymod.block.ModBlocks
package com.example.mymod.block;

import net.minecraft.world.level.block.Block;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.RegistryObject;

public class ModBlocks {
    public static final DeferredRegister<Block> BLOCKS = 
        DeferredRegister.create(net.minecraft.core.registries.Registries.BLOCK, "mymod");

    public static final RegistryObject<Block> RUBY_ORE = BLOCKS.register("ruby_ore", () ->
        new Block(BlockBehaviour.Properties.of()
            .mapColor(MapColor.COLOR_RED)
            .strength(3.0f)
        )
    );

    public static final RegistryObject<Block> RUBY_BLOCK = BLOCKS.register("ruby_block", () ->
        new Block(BlockBehaviour.Properties.of()
            .mapColor(MapColor.COLOR_RED)
            .strength(5.0f, 6.0f)
        )
    );
}
```

```java
// com.example.mymod.item.ModItems
package com.example.mymod.item;

import net.minecraft.world.item.Item;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.RegistryObject;

public class ModItems {
    public static final DeferredRegister<Item> ITEMS = 
        DeferredRegister.create(net.minecraft.core.registries.Registries.ITEM, "mymod");

    public static final RegistryObject<Item> RUBY_INGOT = ITEMS.register("ruby_ingot", () ->
        new Item(new Item.Properties())
    );

    public static final RegistryObject<Item> RUBY_SWORD = ITEMS.register("ruby_sword", () ->
        new SwordItem(Tiers.IRON, 3, -2.4f, new Item.Properties())
    );

    // Block items
    public static final RegistryObject<Item> RUBY_ORE = ITEMS.register("ruby_ore", () ->
        new BlockItem(ModBlocks.RUBY_ORE.get(), new Item.Properties())
    );
}
```

### Step 2: Register DeferredRegisters in Your Main Mod Class

```java
// com.example.mymod.MyMod
package com.example.mymod;

import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.IEventBus;
import net.neoforged.fml.ModContainer;
import net.neoforged.fml.common.Mod;

@Mod("mymod")
public class MyMod {
    public static final String MOD_ID = "mymod";

    public MyMod(IEventBus modEventBus, ModContainer modContainer) {
        // Register all DeferredRegisters
        ModBlocks.BLOCKS.register(modEventBus);
        ModItems.ITEMS.register(modEventBus);
        ModEntities.ENTITY_TYPES.register(modEventBus);
        ModSounds.SOUND_EVENTS.register(modEventBus);

        // Event listeners
        modEventBus.addListener(this::commonSetup);
    }

    private void commonSetup(FMLCommonSetupEvent event) {
        // Common setup tasks after all registrations are complete
    }
}
```

---

## üé® Registering Custom Entities

Custom entities require more setup than simple blocks and items.

### Define Your Entity Class

```java
package com.example.mymod.entity;

import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.level.Level;

public class RubyGolem extends LivingEntity {
    public RubyGolem(EntityType<RubyGolem> entityType, Level level) {
        super(entityType, level);
    }

    @Override
    public void tick() {
        super.tick();
        // Custom behavior goes here
    }
}
```

### Register the Entity Type

```java
package com.example.mymod.entity;

import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.MobCategory;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.RegistryObject;

public class ModEntities {
    public static final DeferredRegister<EntityType<?>> ENTITY_TYPES = 
        DeferredRegister.create(net.minecraft.core.registries.Registries.ENTITY_TYPE, "mymod");

    public static final RegistryObject<EntityType<RubyGolem>> RUBY_GOLEM =
        ENTITY_TYPES.register("ruby_golem", () ->
            EntityType.Builder.of(RubyGolem::new, MobCategory.MONSTER)
                .sized(1.4f, 2.1f)  // width, height
                .build("ruby_golem")
        );
}
```

### Create Entity Renderer (Client-side)

```java
package com.example.mymod.client.entity;

import com.example.mymod.entity.RubyGolem;
import net.minecraft.client.renderer.entity.EntityRendererProvider;
import net.minecraft.client.renderer.entity.MobRenderer;
import net.minecraft.resources.ResourceLocation;

public class RubyGolemRenderer extends MobRenderer<RubyGolem, RubyGolemModel> {
    public RubyGolemRenderer(EntityRendererProvider.Context context) {
        super(context, new RubyGolemModel(context.bakeLayer(RubyGolemModel.LAYER_LOCATION)), 0.5f);
    }

    @Override
    public ResourceLocation getTextureLocation(RubyGolem entity) {
        return new ResourceLocation("mymod", "textures/entity/ruby_golem.png");
    }
}
```

---

## üîä Registering Custom Sounds

Sounds are registered as `SoundEvent` objects that reference audio files.

### Register Sound Events

```java
package com.example.mymod.sound;

import net.minecraft.resources.ResourceLocation;
import net.minecraft.sounds.SoundEvent;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.RegistryObject;

public class ModSounds {
    public static final DeferredRegister<SoundEvent> SOUND_EVENTS = 
        DeferredRegister.create(net.minecraft.core.registries.Registries.SOUND_EVENT, "mymod");

    public static final RegistryObject<SoundEvent> RUBY_BREAK = SOUND_EVENTS.register("ruby_break", () ->
        SoundEvent.createVariableRangeEvent(new ResourceLocation("mymod", "ruby_break"))
    );

    public static final RegistryObject<SoundEvent> RUBY_STEP = SOUND_EVENTS.register("ruby_step", () ->
        SoundEvent.createVariableRangeEvent(new ResourceLocation("mymod", "ruby_step"))
    );
}
```

### Add Audio Files

Place OGG-format audio files in your resources:

```
src/main/resources/assets/mymod/sounds/
‚îú‚îÄ‚îÄ ruby_break.ogg
‚îî‚îÄ‚îÄ ruby_step.ogg
```

### Reference Sounds in Code

```java
// In a block or entity
entity.playSound(ModSounds.RUBY_BREAK.get(), 1.0f, 1.0f);
```

---

## üåç Registering Custom Dimensions

Dimensions are complex registries that enable custom worlds and realms.

### Register Dimension Type

```java
package com.example.mymod.dimension;

import net.minecraft.core.registries.Registries;
import net.minecraft.world.level.dimension.DimensionType;
import net.neoforged.neoforge.registries.DeferredRegister;
import net.neoforged.neoforge.registries.RegistryObject;
import java.util.OptionalLong;

public class ModDimensions {
    public static final DeferredRegister<DimensionType> DIMENSION_TYPES = 
        DeferredRegister.create(Registries.DIMENSION_TYPE, "mymod");

    public static final RegistryObject<DimensionType> RUBY_DIM = 
        DIMENSION_TYPES.register("ruby_dimension", () ->
            new DimensionType(
                OptionalLong.empty(),           // no fixed time
                true,                           // has skylight
                false,                          // no ceiling
                false,                          // no raids
                false,                          // no dragons
                1.0,                            // coordinate scale
                true,                           // bed works
                true,                           // respawn anchor works
                -64,                            // min Y
                384,                            // height
                384,                            // logical height
                net.minecraft.world.level.block.Blocks.DEEPSLATE.defaultBlockState(), // infiniburn
                net.minecraft.resources.ResourceLocation.withDefaultNamespace("overworld"), // effects
                0.1f,                           // ambient light
                new net.minecraft.world.level.dimension.DimensionType.MonsterSettings(false, false, OptionalLong.empty(), 0)
            )
        );
}
```

### Register the Dimension Itself

This requires a **level.dat** modification or datapack. For modded dimensions, use:

```java
net.neoforged.neoforge.event.level.LevelEvent.Load event;
// Check if it's your custom level type
```

---

## üìä Best Practices for Registry Organization

### Directory Structure

Organize registries by their purpose:

```java
com.example.mymod/
‚îú‚îÄ‚îÄ block/
‚îÇ   ‚îî‚îÄ‚îÄ ModBlocks.java              ‚Üê All block registrations
‚îú‚îÄ‚îÄ item/
‚îÇ   ‚îî‚îÄ‚îÄ ModItems.java               ‚Üê All item registrations
‚îú‚îÄ‚îÄ entity/
‚îÇ   ‚îú‚îÄ‚îÄ ModEntities.java            ‚Üê Entity type registrations
‚îÇ   ‚îî‚îÄ‚îÄ (custom entity classes)
‚îú‚îÄ‚îÄ sound/
‚îÇ   ‚îî‚îÄ‚îÄ ModSounds.java              ‚Üê Sound event registrations
‚îú‚îÄ‚îÄ dimension/
‚îÇ   ‚îî‚îÄ‚îÄ ModDimensions.java          ‚Üê Dimension registrations
‚îî‚îÄ‚îÄ MyMod.java                      ‚Üê Main class; registers all
```

### Naming Conventions

- **Class names:** Plural (ModBlocks, ModItems, ModEntities)
- **Field names:** UPPER_CASE_WITH_UNDERSCORES
- **Registry IDs:** lowercase_with_underscores (matches JSON/data file naming)

```java
// ‚úÖ Good
public static final RegistryObject<Block> RUBY_ORE = BLOCKS.register("ruby_ore", ...);

// ‚ùå Bad
public static final RegistryObject<Block> rubyOre = BLOCKS.register("RubyOre", ...);
```

### Preventing Initialization Errors

Always use `RegistryObject.get()` to safely retrieve registered objects:

```java
// ‚úÖ Safe ‚Äî guaranteed to be initialized
ItemStack sword = new ItemStack(ModItems.RUBY_SWORD.get());

// ‚ùå Unsafe ‚Äî field might not be initialized
ItemStack sword = new ItemStack(ModItems.RUBY_SWORD);
```

---

## üêõ Common Registry Mistakes

| Mistake | Symptom | Solution |
|---|---|---|
| Forgetting to register DeferredRegister | Items/blocks don't appear | Call `BLOCKS.register(eventBus)` in main mod class |
| Using wrong registry type | "Cannot find symbol" errors | Use `Registries.BLOCK` for blocks, not `Registries.ITEM` |
| Accessing uninitialized object | NullPointerException at startup | Always use `.get()` to retrieve from RegistryObject |
| Duplicate registration IDs | Confusing crashes at world load | Ensure ID strings are unique within each registry |
| Missing texture/model files | Missing textures/purple blocks | Create corresponding JSON model files in assets |

---

## ‚úÖ Checklist

- [ ] DeferredRegister instances created for each registry type
- [ ] DeferredRegister.register() called in main mod class
- [ ] All RegistryObject references use `.get()` method
- [ ] Texture and model JSON files exist for all items/blocks
- [ ] Sound files (if used) are in OGG format and referenced correctly
- [ ] Language file (en_us.json) includes display names

---

> **Next:** [Events & Networking](10.-Events-Networking)


