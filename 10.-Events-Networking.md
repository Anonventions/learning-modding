# 10. Events & Networking

> **Wiki home:** [Home](Home) | **Previous:** [Registry Systems](9.-Registry-Systems)

This page covers how to hook into Minecraft's event lifecycle using NeoForge's Event Bus, and how to synchronize data between server and client using custom network packets.

---

## üé™ Understanding the Event Bus

The **Event Bus** is NeoForge's publish-subscribe system. It allows your mod to "listen" for specific game events (block breaks, player joins, entity dies) and respond with custom logic.

### Event Bus Terminology

| Term | Meaning |
|---|---|
| **Event** | Something happening in the game (e.g., "player just broke a block") |
| **Listener** | A method in your code that gets called when an event occurs |
| **Subscribe** | Register your listener so the bus calls it |
| **Event Bus** | The central system that broadcasts events to all listeners |

### The Event Lifecycle

```
Game event occurs
        ‚Üì
Event Bus broadcasts the event
        ‚Üì
All subscribed listeners are called simultaneously
        ‚Üì
Your listener executes custom logic
        ‚Üì
Your listener can cancel the event or modify it
```

---

## üé£ Creating Your First Event Listener

### Step 1: Create a Listener Class

```java
package com.example.mymod.event;

import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.block.Blocks;
import net.minecraftforge.event.level.BlockEvent;

@EventBusSubscriber(modid = "mymod", bus = EventBusSubscriber.Bus.FORGE)
public class BlockBreakListener {

    @SubscribeEvent
    public static void onBlockBreak(BlockEvent.BreakEvent event) {
        Player player = event.getPlayer();
        
        // Example: Print message when a player breaks a Ruby Ore block
        if (event.getState().getBlock() == ModBlocks.RUBY_ORE.get()) {
            if (!player.level().isClientSide) {  // Server-side only
                player.displayClientMessage(
                    net.minecraft.network.chat.Component.literal("You found some Ruby!"),
                    false  // above hotbar
                );
            }
        }
    }
}
```

### Step 2: Register the Listener in Your Main Mod Class

```java
@Mod("mymod")
public class MyMod {
    public static final String MOD_ID = "mymod";

    public MyMod(IEventBus modEventBus, ModContainer modContainer) {
        modEventBus.addListener(this::commonSetup);
        
        // Register your event listeners
        net.neoforged.fml.loading.FXModLoadingContext.getInstance()
            .getModEventBus()
            .register(BlockBreakListener.class);
    }

    private void commonSetup(FMLCommonSetupEvent event) { }
}
```

---

## üìã Common Event Types

### Entity Events

| Event | Fired when... | Cancellable |
|---|---|---|
| `LivingDeathEvent` | An entity dies | ‚úÖ Yes (entity survives) |
| `LivingHurtEvent` | An entity takes damage | ‚úÖ Yes (no damage taken) |
| `LivingAttackEvent` | An entity is attacked | ‚úÖ Yes |
| `LivingSpawnEvent` | An entity spawns | ‚úÖ Yes |
| `LivingEquipmentChangeEvent` | Player changes armor/tool | ‚ùå No |

```java
@SubscribeEvent
public static void onPlayerDamage(LivingHurtEvent event) {
    if (event.getEntity() instanceof Player player && !player.level().isClientSide) {
        // Custom damage reduction logic
        if (player.getItemBySlot(EquipmentSlot.CHEST).getItem() == ModItems.RUBY_ARMOR.get()) {
            event.setAmount(event.getAmount() * 0.75f);  // 25% damage reduction
        }
    }
}
```

### Player Events

| Event | Fired when... | Cancellable |
|---|---|---|
| `PlayerEvent.PlayerLoggedInEvent` | Player joins server | ‚ùå No |
| `PlayerEvent.PlayerLoggedOutEvent` | Player leaves server | ‚ùå No |
| `PlayerEvent.ItemPickupEvent` | Player picks up item | ‚úÖ Yes |
| `PlayerEvent.PlayerChangedDimensionEvent` | Player changes dimensions | ‚ùå No |

```java
@SubscribeEvent
public static void onPlayerJoin(PlayerEvent.PlayerLoggedInEvent event) {
    Player player = event.getEntity();
    if (!player.level().isClientSide) {
        player.displayClientMessage(
            net.minecraft.network.chat.Component.literal("Welcome to Tutorial Mod!"),
            false
        );
    }
}
```

### Block Events

| Event | Fired when... | Cancellable |
|---|---|---|
| `BlockEvent.BreakEvent` | A block is broken | ‚úÖ Yes (block stays) |
| `BlockEvent.EntityPlaceEvent` | A block is placed | ‚úÖ Yes (block not placed) |
| `BlockEvent.FarmlandTrampleEvent` | Farmland is trampled | ‚úÖ Yes (farmland stays) |

### World/Tick Events

| Event | Fired when... |
|---|---|
| `TickEvent.ServerTickEvent` | Server ticks (20/second) |
| `TickEvent.ClientTickEvent` | Client ticks (varies) |
| `LevelEvent.Load` | A world/dimension loads |
| `LevelEvent.Unload` | A world/dimension unloads |

```java
@SubscribeEvent
public static void onServerTick(TickEvent.ServerTickEvent event) {
    if (event.phase == TickEvent.Phase.END) {  // Execute at end of tick
        // Check something every tick
        // Warning: This runs every tick! Cache calculations!
    }
}
```

---

## ‚öôÔ∏è Event Prioritization and Phases

Events have two phases: **PRE** and **POST**.

```
Block Break Event
        ‚Üì
PRE-event listeners run (you can cancel here)
        ‚Üì
Vanilla logic executes (if not cancelled)
        ‚Üì
POST-event listeners run (event already happened)
```

Specify priority and phase with `@SubscribeEvent`:

```java
@SubscribeEvent(priority = EventPriority.HIGH)  // Higher = runs first
public static void onBlockBreakPre(BlockEvent.BreakEvent event) {
    if (event.getState().getBlock() == Blocks.DIAMOND_ORE) {
        event.setCanceled(true);  // Prevent breaking diamond ore
    }
}
```

---

## üåê Network Synchronization: Server ‚Üî Client

Minecraft is architected as **client-server**, even in single-player:

- **Server:** Holds the "truth" ‚Äî actual game state, physics, mob positions
- **Client:** Renders what the server tells it to render

When you need to:
- Show a visual effect to a player
- Update custom data between server and client
- Send commands from client to server

...you need **network packets**.

### Problem Example

```java
// ‚ùå This doesn't work
@SubscribeEvent
public static void onPlayerAttack(LivingAttackEvent event) {
    if (event.getEntity().getMainHandItem().getItem() == ModItems.RUBY_SWORD.get()) {
        // Server knows the attack happened
        // But client doesn't know to display a special effect
        // Players see nothing special!
    }
}
```

### Solution: Custom Network Packets

---

## üì§ Creating and Sending Custom Packets

### Step 1: Define Your Packet Class

```java
package com.example.mymod.network;

import io.netty.buffer.ByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public class RubySwordAttackPacket implements CustomPacketPayload {
    public static final ResourceLocation ID = 
        new ResourceLocation("mymod", "ruby_sword_attack");
    
    public static final StreamCodec<ByteBuf, RubySwordAttackPacket> CODEC =
        StreamCodec.unit(new RubySwordAttackPacket());

    @Override
    public ResourceLocation id() {
        return ID;
    }
}
```

### Step 2: Handle the Packet (Client Side)

```java
// ‚úÖ Only executed on client receiving the packet
public class ClientPacketHandler {
    public static void handleRubySwordAttack(RubySwordAttackPacket packet, IPayloadContext context) {
        context.enqueueWork(() -> {
            // Client-side rendering logic
            double x = Minecraft.getInstance().player.getX();
            double y = Minecraft.getInstance().player.getY();
            double z = Minecraft.getInstance().player.getZ();
            
            // Spawn a custom particle effect
            for (int i = 0; i < 5; i++) {
                Minecraft.getInstance().particleEngine.createTrackingEmitter(
                    Minecraft.getInstance().player,
                    ParticleTypes.FLAME  // or your custom particle
                );
            }
        });
    }
}
```

### Step 3: Register the Packet

In your main mod class:

```java
@Mod("mymod")
public class MyMod {
    public MyMod(IEventBus modEventBus, ModContainer modContainer) {
        // Register network handler
        modEventBus.addListener(this::registerPackets);
    }

    private void registerPackets(FMLCommonSetupEvent event) {
        MyModNetworkHandler.register();
    }
}
```

In `MyModNetworkHandler.java`:

```java
package com.example.mymod.network;

import net.neoforged.api.distmarker.Dist;
import net.neoforged.fml.loading.FXModLoadingContext;
import net.neoforged.neoforge.network.handling.IPayloadContext;

public class MyModNetworkHandler {
    public static void register() {
        var networkHandler = FXModLoadingContext.getInstance()
            .getPayloadEvent(RubySwordAttackPacket.ID);
        
        networkHandler.receiver()
            .client(ClientPacketHandler::handleRubySwordAttack);
    }
}
```

### Step 4: Send the Packet from Server

```java
@SubscribeEvent
public static void onPlayerAttack(LivingAttackEvent event) {
    if (event.getSource().getEntity() instanceof ServerPlayer player) {
        if (player.getMainHandItem().getItem() == ModItems.RUBY_SWORD.get()) {
            // Send packet to client
            ModPacketHandler.sendToClient(
                new RubySwordAttackPacket(),
                player
            );
        }
    }
}
```

---

## üì° Bidirectional Packets (Client ‚Üí Server)

For player actions (button clicks, custom interactions), you need packets flowing from client to server.

### Client sends ‚Üí Server receives

```java
@SubscribeEvent(Side = Dist.CLIENT)
public static void onMouseClick(InputEvent.MouseButton.Pre event) {
    if (event.getButton() == 1) {  // Right-click
        // Send packet to server
        ModPacketHandler.sendToServer(new CustomActionPacket("interact"));
    }
}
```

On server:

```java
public static void handleCustomAction(CustomActionPacket packet, IPayloadContext context) {
    context.enqueueWork(() -> {
        ServerPlayer player = context.getPlayer();
        if (player != null) {
            // Server-side logic
            player.displayClientMessage(
                Component.literal("Server received: " + packet.action),
                false
            );
        }
    });
}
```

---

## üé® Common Packet Patterns

### Pattern 1: Particle Effect on Block Break

```java
@SubscribeEvent
public static void onBlockBreak(BlockEvent.BreakEvent event) {
    if (event.getState().getBlock() == ModBlocks.RUBY_ORE.get()) {
        if (event.getLevel() instanceof ServerLevel serverLevel) {
            serverLevel.getAllPlayers().forEach(player -> 
                ModPacketHandler.sendToClient(
                    new ParticleEffectPacket(event.getPos()),
                    player
                )
            );
        }
    }
}
```

### Pattern 2: Sync Custom NBT Data

```java
// When item data changes on server
ItemStack stack = player.getMainHandItem();
stack.set(MyComponents.CUSTOM_DATA, newData);

// Send update to client
ModPacketHandler.sendToClient(
    new ItemDataSyncPacket(stack.copy()),
    player
);
```

### Pattern 3: Periodic Data Updates

```java
@SubscribeEvent
public static void onServerTick(TickEvent.ServerTickEvent event) {
    if (event.phase == TickEvent.Phase.END && event.getServer().getTickCount() % 20 == 0) {
        // Every 20 ticks (1 second), update clients
        event.getServer().getPlayerList().getPlayers().forEach(player -> {
            // Send health, level, or other custom data
        });
    }
}
```

---

## ‚ö†Ô∏è Critical Rules for Networking

### 1. **Never trust the client**

```java
// ‚ùå WRONG - Client can modify money directly
if (packet.money > playerBalance) {
    playerBalance = packet.money;  // Cheating!
}

// ‚úÖ RIGHT - Server performs validation
if (packet.moneyToWithdraw <= playerBalance) {
    playerBalance -= packet.moneyToWithdraw;
    // Server tells client the new balance
}
```

### 2. **Execute on the correct logical side**

```java
// ‚ùå WRONG - This packet handler isn't marked which side
public static void handlePacket(MyPacket packet) {
    player.setInvisible(true);  // Might run on wrong side
}

// ‚úÖ RIGHT - Specify the logical side
@SubscribeEvent
@Dist(Dist.CLIENT)
public static void handleParticle(ParticlePacket packet) {
    // This only runs on the client
}
```

### 3. **Enqueue work off the network thread**

```java
// ‚ùå WRONG - Network operations on game thread
public static void handle(MyPacket packet, IPayloadContext context) {
    Minecraft.getInstance().execute(() -> { });  // ERROR
}

// ‚úÖ RIGHT - Use enqueueWork
public static void handle(MyPacket packet, IPayloadContext context) {
    context.enqueueWork(() -> {
        // Safe to access Minecraft instance here
        Minecraft.getInstance().particleEngine.createTrackingEmitter(...);
    });
}
```

---

## üêõ Debugging Networking Issues

### Packet not received?

1. **Check mod ID:** Make sure packet registration uses correct `MOD_ID`
2. **Check channel name:** Both sides must register on the same channel
3. **Check payload ID:** Server and client IDs must match exactly

### Player doesn't see the effect?

1. **Check logical side:** Is the rendering code on the client?
2. **Check context:** Did you use `context.enqueueWork()`?
3. **Check the player:** Are you sending to the right player?

---

## üìã Complete Event Listener Example

```java
package com.example.mymod.event;

import net.neoforged.api.distmarker.Dist;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.block.Blocks;
import net.minecraftforge.event.entity.living.LivingAttackEvent;
import net.minecraftforge.event.level.BlockEvent;

@EventBusSubscriber(modid = "mymod", bus = EventBusSubscriber.Bus.FORGE)
public class ModEvents {

    @SubscribeEvent
    public static void onBlockBreak(BlockEvent.BreakEvent event) {
        if (event.getState().getBlock() == ModBlocks.RUBY_ORE.get()) {
            event.getPlayer().displayClientMessage(
                Component.literal("¬ßcYou mined Ruby Ore!"),
                false
            );
        }
    }

    @SubscribeEvent
    public static void onPlayerHurt(LivingAttackEvent event) {
        if (event.getEntity() instanceof Player player && !player.level().isClientSide) {
            // Custom armor logic
            if (player.getItemBySlot(EquipmentSlot.CHEST).getItem() 
                == ModItems.RUBY_CHESTPLATE.get()) {
                event.setCanceled(true);  // Invulnerability for demo
            }
        }
    }
}
```

---

## ‚úÖ Checklist

- [ ] Event listeners use `@EventBusSubscriber` annotation
- [ ] All listeners are static methods with `@SubscribeEvent`
- [ ] Server-side logic checks `!level.isClientSide`
- [ ] Packets implement `CustomPacketPayload`
- [ ] Packets have `StreamCodec` for serialization
- [ ] Packet handlers use `context.enqueueWork()`
- [ ] Network communication validates on server
- [ ] Client doesn't trust client-side calculations for important logic

---

> **Back to:** [Registry Systems](9.-Registry-Systems) | **Wiki home:** [Home](Home)


